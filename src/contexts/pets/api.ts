
import { supabase } from '@/integrations/supabase/client';
import { Pet, NewPetData } from './types';
import { toast } from 'sonner';

// Define database record type to match Supabase schema
interface PetRecord {
  id: string;
  name: string;
  breed: string;
  type: string; // 'dog' or 'cat'
  gender: string; // 'male' or 'female'
  birth_or_adoption_date: string;
  photo_url: string;
  pet_identifier?: string; // Pet ID generated by database trigger
  user_id: string;
  archived: boolean;
  created_at: string;
  updated_at: string;
}

// Get pets from Supabase
export const fetchPetsFromSupabase = async (userId: string) => {
  try {
    // Fetch active pets
    const { data: activePets, error: activeError } = await supabase
      .from('pets')
      .select('*')
      .eq('user_id', userId)
      .eq('archived', false)
      .order('created_at', { ascending: false }) as { data: PetRecord[] | null, error: any };

    if (activeError) throw activeError;

    // Fetch archived pets
    const { data: archivedPetsData, error: archivedError } = await supabase
      .from('pets')
      .select('*')
      .eq('user_id', userId)
      .eq('archived', true)
      .order('created_at', { ascending: false }) as { data: PetRecord[] | null, error: any };

    if (archivedError) throw archivedError;

    // Convert any public URLs to signed URLs for pet photos
    const convertToSignedUrl = async (url: string | null) => {
      if (!url || !url.includes('/pet-photos/')) return '';
      
      try {
        // Extract the path from the URL
        const urlObj = new URL(url);
        const pathParts = urlObj.pathname.split('/');
        const bucketIndex = pathParts.findIndex(part => part === 'pet-photos');
        if (bucketIndex === -1) return url;
        
        const filePath = pathParts.slice(bucketIndex + 1).join('/');
        
        // Create a signed URL
        const { data } = await supabase.storage
          .from('pet-photos')
          .createSignedUrl(filePath, 60 * 60 * 24); // 1 day expiry
          
        return data?.signedUrl || url;
      } catch (error) {
        console.error('Error converting to signed URL:', error);
        return url;
      }
    };

    // Map database format to our app's Pet interface with signed URLs
    const mappedActivePets = await Promise.all(activePets.map(async dbPet => ({
      id: dbPet.id,
      name: dbPet.name,
      breed: dbPet.breed || '',
      birthDate: dbPet.birth_or_adoption_date || '',
      photoUrl: await convertToSignedUrl(dbPet.photo_url),
      petIdentifier: dbPet.pet_identifier || '',
      archived: false
    })));

    const mappedArchivedPets = await Promise.all(archivedPetsData.map(async dbPet => ({
      id: dbPet.id,
      name: dbPet.name,
      breed: dbPet.breed || '',
      birthDate: dbPet.birth_or_adoption_date || '',
      photoUrl: await convertToSignedUrl(dbPet.photo_url),
      petIdentifier: dbPet.pet_identifier || '',
      archived: true
    })));

    return { active: mappedActivePets, archived: mappedArchivedPets };
  } catch (error) {
    console.error('Error loading pets from Supabase:', error);
    throw error;
  }
};

// Add a new pet to Supabase
// Note: photoFile is optional - if not provided, an empty string will be used for photo_url
export const addPetToSupabase = async (userId: string, petData: NewPetData) => {
  console.log('Adding pet to Supabase:', petData);
  try {
    let photoUrl = '';
    
    // Upload photo if provided
    if (petData.photoFile) {
      const fileExt = petData.photoFile.name.split('.').pop();
      const filePath = `${userId}/${Date.now()}.${fileExt}`;
      
      const { error: uploadError, data } = await supabase.storage
        .from('pet-photos')
        .upload(filePath, petData.photoFile);
        
      if (uploadError) {
        console.error('Error uploading pet photo:', uploadError);
        throw uploadError;
      }
      
      // Get a signed URL that will work with private buckets
      const { data: urlData } = await supabase.storage
        .from('pet-photos')
        .createSignedUrl(filePath, 60 * 60 * 24); // 1 day expiry
      
      if (!urlData) {
        throw new Error('Failed to create signed URL for pet photo');
      }
        
      photoUrl = urlData.signedUrl;
    }

    // Insert pet data into database
    const { data: newPet, error } = await supabase
      .from('pets')
      .insert({
        user_id: userId,
        name: petData.name,
        breed: petData.breed,
        birth_or_adoption_date: petData.birthDate,
        type: 'dog', // Default to dog for now, should be passed in petData
        gender: 'male', // Default to male for now, should be passed in petData
        photo_url: photoUrl,
        archived: false
      })
      .select()
      .single() as { data: PetRecord | null, error: any };

    if (error) {
      console.error('Error inserting pet data:', error);
      throw error;
    }

    if (!newPet) {
      throw new Error('No pet data returned from the database');
    }

    console.log('Successfully added pet to Supabase:', newPet);

    // Map to Pet type
    return {
      id: newPet.id,
      name: newPet.name,
      breed: newPet.breed || '',
      birthDate: newPet.birth_or_adoption_date || '',
      photoUrl: newPet.photo_url || '',
      archived: false
    };
  } catch (error) {
    console.error('Error adding pet to Supabase:', error);
    throw error;
  }
};

// Archive a pet in Supabase
export const archivePetInSupabase = async (petId: string) => {
  try {
    const { error } = await supabase
      .from('pets')
      .update({ archived: true })
      .eq('id', petId);
      
    if (error) throw error;
    return true;
  } catch (error) {
    console.error('Error archiving pet in Supabase:', error);
    throw error;
  }
};

// Restore a pet from archive in Supabase
export const restorePetInSupabase = async (petId: string) => {
  try {
    const { error } = await supabase
      .from('pets')
      .update({ archived: false })
      .eq('id', petId);
      
    if (error) throw error;
    return true;
  } catch (error) {
    console.error('Error restoring pet in Supabase:', error);
    throw error;
  }
};

// Permanently delete a pet from Supabase
export const deletePetFromSupabase = async (petId: string) => {
  console.log('Calling deletePetFromSupabase for pet ID:', petId);
  try {
    const { error } = await supabase
      .from('pets')
      .delete()
      .eq('id', petId);
      
    if (error) {
      console.error('Supabase error deleting pet:', error);
      throw error;
    }
    console.log('Successfully deleted pet from Supabase');
    return true;
  } catch (error) {
    console.error('Error permanently deleting pet from Supabase:', error);
    throw error;
  }
};

// Update pet details in Supabase
export const updatePetInSupabase = async (petId: string, petData: Partial<Omit<Pet, 'id'>>) => {
  try {
    // Prepare data for update
    const updateData: any = {};
    if (petData.name) updateData.name = petData.name;
    if (petData.breed) updateData.breed = petData.breed;
    if (petData.birthDate) updateData.birth_date = petData.birthDate;
    
    // Handle photo URL updates
    if (petData.photoUrl) {
      // Store the URL as is - we'll handle signed URL conversion when fetching
      // This is consistent with our private bucket approach
      updateData.photo_url = petData.photoUrl;
      
      // Note: For a more robust solution, we could extract the file path
      // from the URL and store that instead of the full signed URL,
      // but this would require changes to the fetch logic as well.
    }
    
    // Update in database
    const { error } = await supabase
      .from('pets')
      .update(updateData)
      .eq('id', petId);
      
    if (error) throw error;
    
    return true;
  } catch (error) {
    console.error('Error updating pet in Supabase:', error);
    throw error;
  }
};
